
# SPDX-FileCopyrightText: 2022 Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import datetime
from uuid import UUID

from more_itertools import one

from autogenerated_graphql_client import GetManagersManagersObjects


def extract_managers_with_no_persons_or_engagements(
    manager_objects: list[GetManagersManagersObjects],
) -> list[dict[str, UUID] | dict[str, datetime.datetime | None]]:
    """
    Function for pulling UUID(s) out on all manager roles, that does
    not have a person, or an engagement associated to it.

    Args:
        manager_objects: A current list of manager objects

    Returns:
        A list of dict with:
         UUID(s) on all manager roles with no person or engagement.
         Dates on the managers farthest engagement end date.
    Example:
        "[{'uuid': '083de7f8-d52f-456d-a351-44075cbc0ca5', 'termination_date': '2023-08-11'},
        {'uuid': '21926ae9-5479-469a-97ae-3a996a7b3a01', 'termination_date': '2023-07-26'}]"
    """
    termination_objects = []
    for manager in manager_objects:
        manager_org_unit_uuid = one(one(manager.objects).org_unit).uuid
        manager_uuid = one(manager.objects).uuid

        # Managers engagement details
        employee_data = one(manager.objects).employee

        # If "employee": None or the "employee": [{"engagements": []}]
        if employee_data is None or all(
            len(e.engagements) == 0 for e in employee_data
        ):
            # Use today, if no person or engagements are found.
            termination_objects.append(
                {
                    "uuid": manager_uuid,
                    "termination_date": datetime.date.today().isoformat(),
                }
            )

        farthest_to_date = None

        if employee_data:
            for employee in employee_data:
                engagements = employee.engagements
                for engagement in engagements:
                    engagement_org_unit_uuid = one(engagement.org_unit).uuid
                    engagement_validity_to = engagement.validity.to
                    if (  # If there's a match and engagement has an end date.
                        engagement_org_unit_uuid == manager_org_unit_uuid
                    ) and engagement_validity_to:
                        if (
                            farthest_to_date is None
                            or engagement_validity_to
                            > farthest_to_date
                        ):
                            # Assign the engagements end date to the farthest date.
                            farthest_to_date = engagement_validity_to

                        termination_objects.append(
                            {
                                "uuid": manager_uuid,
                                "termination_date": farthest_to_date
                            }
                        )

    return termination_objects
