# SPDX-FileCopyrightText: 2023 Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import uuid
from datetime import date
from datetime import datetime
from datetime import timedelta
from datetime import timezone
from unittest.mock import AsyncMock
from unittest.mock import call

import pytest

from manager_terminator.autogenerated_graphql_client.get_engagement_objects_by_uuid import (
    GetEngagementObjectsByUuidEngagements,
)
from manager_terminator.autogenerated_graphql_client.get_managers import (
    GetManagersManagers,
)
from manager_terminator.config import Settings
from manager_terminator.main import engagement_event_handler
from manager_terminator.utils import DEFAULT_TIMEZONE

# test data
test_data_engagement_uuid = uuid.uuid4()
shared_orgunit_uuid = uuid.uuid4()
shared_person_uuid = uuid.uuid4()

test_data_engagement_objs = {
    "objects": [
        {
            "validities": [
                {
                    "uuid": test_data_engagement_uuid,
                    "org_unit": [{"uuid": uuid.uuid4()}],
                    "person": [{"uuid": uuid.uuid4()}],
                    "validity": {
                        "from": datetime(2023, 1, 1, 0, 0, 0).replace(
                            tzinfo=DEFAULT_TIMEZONE
                        ),
                        "to": None,
                    },
                }
            ]
        },
        {
            "validities": [
                {
                    "uuid": test_data_engagement_uuid,
                    "org_unit": [{"uuid": uuid.uuid4()}],
                    "person": [{"uuid": uuid.uuid4()}],
                    "validity": {
                        "from": datetime(2023, 2, 1, 0, 0, 0).replace(
                            tzinfo=DEFAULT_TIMEZONE
                        ),
                        "to": None,
                    },
                }
            ]
        },
        {
            "validities": [
                {
                    "uuid": test_data_engagement_uuid,
                    "org_unit": [{"uuid": shared_orgunit_uuid}],
                    "person": [{"uuid": shared_person_uuid}],
                    "validity": {
                        "from": datetime(2023, 2, 1, 0, 0, 0).replace(
                            tzinfo=DEFAULT_TIMEZONE
                        ),
                        "to": None,
                    },
                }
            ]
        },
        {
            "validities": [
                {
                    "uuid": test_data_engagement_uuid,
                    "org_unit": [{"uuid": shared_orgunit_uuid}],
                    "person": [{"uuid": shared_person_uuid}],
                    "validity": {
                        "from": datetime(2023, 2, 1, 0, 0, 0).replace(
                            tzinfo=DEFAULT_TIMEZONE
                        ),
                        "to": None,
                    },
                }
            ]
        },
        {
            "validities": [
                {
                    "uuid": test_data_engagement_uuid,
                    "org_unit": [{"uuid": uuid.uuid4()}],
                    "person": [{"uuid": uuid.uuid4()}],
                    "validity": {
                        "from": datetime(2023, 1, 1, 0, 0, 0).replace(
                            tzinfo=DEFAULT_TIMEZONE
                        ),
                        "to": datetime(2023, 2, 28, 0, 0, 0).replace(
                            tzinfo=DEFAULT_TIMEZONE
                        ),
                    },
                }
            ]
        },
    ]
}

test_data_managers = {
    "objects": [
        {
            "validities": [
                {
                    "uuid": uuid.uuid4(),
                    "org_unit": [
                        {
                            "uuid": test_data_engagement_objs["objects"][0][
                                "validities"
                            ][0]["org_unit"][0]["uuid"]
                        }
                    ],
                    "person": [
                        {
                            "uuid": test_data_engagement_objs["objects"][0][
                                "validities"
                            ][0]["person"][0]["uuid"],
                            "engagements": [
                                test_data_engagement_objs["objects"][0]["validities"][0]
                            ],
                        }
                    ],
                    "validity": {
                        "from": datetime(2023, 1, 1, 0, 0, 0).replace(
                            tzinfo=DEFAULT_TIMEZONE
                        ),
                        "to": None,
                    },
                }
            ],
        },
        {
            "validities": [
                {
                    "uuid": test_data_engagement_objs["objects"][1]["validities"][0][
                        "org_unit"
                    ][0]["uuid"],
                    "org_unit": [{"uuid": uuid.uuid4()}],
                    "person": [
                        {
                            "uuid": test_data_engagement_objs["objects"][1][
                                "validities"
                            ][0]["person"][0]["uuid"],
                            "engagements": [
                                test_data_engagement_objs["objects"][1]["validities"][0]
                            ],
                        }
                    ],
                    "validity": {
                        "from": datetime(2023, 1, 1, 0, 0, 0).replace(
                            tzinfo=DEFAULT_TIMEZONE
                        ),
                        "to": None,
                    },
                }
            ]
        },
        {
            "validities": [
                {
                    "uuid": uuid.uuid4(),
                    "org_unit": [
                        {
                            "uuid": test_data_engagement_objs["objects"][4][
                                "validities"
                            ][0]["org_unit"][0]["uuid"]
                        }
                    ],
                    "person": [
                        {
                            "uuid": test_data_engagement_objs["objects"][4][
                                "validities"
                            ][0]["person"][0]["uuid"],
                            "engagements": [
                                test_data_engagement_objs["objects"][4]["validities"][0]
                            ],
                        }
                    ],
                    "validity": {
                        "from": datetime(2023, 1, 1, 0, 0, 0).replace(
                            tzinfo=DEFAULT_TIMEZONE
                        ),
                        "to": None,
                    },
                }
            ]
        },
    ]
}


@pytest.mark.asyncio
@pytest.mark.usefixtures("minimal_valid_settings")
async def test_engagement_event_handler():
    """Tests the engagement_event_handler."""

    settings = Settings()

    # mocking
    get_engagement_objects_by_uuids_mock = AsyncMock(
        return_value=GetEngagementObjectsByUuidEngagements.parse_obj(
            test_data_engagement_objs
        )
    )

    get_employee_managers_mock = AsyncMock(
        return_value=GetManagersManagers.parse_obj(test_data_managers)
    )
    terminate_manager_mock = AsyncMock(
        return_value=test_data_managers["objects"][1]["validities"][0]["uuid"]
    )

    mo_mock = AsyncMock(
        get_engagement_objects_by_uuids=get_engagement_objects_by_uuids_mock,
        get_employee_managers=get_employee_managers_mock,
        terminate_manager=terminate_manager_mock,
    )
    # invoke
    await engagement_event_handler(mo_mock, test_data_engagement_uuid, settings, None)

    # asserts
    get_engagement_objects_by_uuids_mock.assert_called_once()
    get_employee_managers_mock.assert_has_calls(
        [
            call(
                # OBS: We convert a set to a list, since this is how the logic does it
                # and if we just use an array directly, the array passed to the
                # function, will be sorted, which will make the test fail.
                list(
                    {
                        test_data_engagement_objs["objects"][0]["validities"][0][
                            "person"
                        ][0]["uuid"],
                        test_data_engagement_objs["objects"][1]["validities"][0][
                            "person"
                        ][0]["uuid"],
                        test_data_engagement_objs["objects"][2]["validities"][0][
                            "person"
                        ][0]["uuid"],
                        test_data_engagement_objs["objects"][4]["validities"][0][
                            "person"
                        ][0]["uuid"],
                    }
                )
            )
        ]
    )
    terminate_manager_mock.assert_has_calls(
        [
            call(
                uuid=test_data_managers["objects"][1]["validities"][0]["uuid"],
                terminate_from=date(2023, 1, 1),
                terminate_to=date(2023, 1, 31),
            ),
            call(
                uuid=test_data_managers["objects"][2]["validities"][0]["uuid"],
                terminate_from=None,
                terminate_to=test_data_engagement_objs["objects"][4]["validities"][0][
                    "validity"
                ]["to"].date(),
            ),
        ]
    )


@pytest.mark.asyncio
@pytest.mark.usefixtures("minimal_valid_settings")
async def test_update_engagement_event_handler(monkeypatch: pytest.MonkeyPatch):
    """
    Tests the engagement_event_handler.

                               | 2015-01-01 → 2015-01-09| 2015-01-10 → 2015-01-15| 2015-01-15 → 2015-01-30| 2015-01-30 → ∞         |
    Manager validity           |------------------------|------------------------|------------------------|------------------------>
    Manager engagements        |                        |--------- E1 -----------|---------- E2 ----------|
    "Assert" vacant periods    |------- vacant ---------|                        |                        |------- vacant --------->
    """

    with monkeypatch.context() as con:
        con.setenv("MANAGER_TERMINATOR__SET_TO_VACANT", "True")
        settings = Settings()

        engagement_uuid = uuid.uuid4()
        org_unit_uuid = uuid.uuid4()
        manager_uuid = uuid.uuid4()

        mo = AsyncMock()
        mo.get_engagement_objects_by_uuids.return_value = (
            GetEngagementObjectsByUuidEngagements.parse_obj(
                {
                    "objects": [
                        {
                            "validities": [
                                {
                                    "uuid": engagement_uuid,
                                    "person": [{"uuid": uuid.uuid4()}],
                                    "org_unit": [{"uuid": org_unit_uuid}],
                                    "validity": {
                                        "from": datetime(
                                            2015,
                                            1,
                                            10,
                                            tzinfo=timezone(timedelta(hours=1)),
                                        ),
                                        "to": datetime(
                                            2015,
                                            1,
                                            15,
                                            tzinfo=timezone(timedelta(hours=1)),
                                        ),
                                    },
                                },
                                {
                                    "uuid": engagement_uuid,
                                    "person": [{"uuid": uuid.uuid4()}],
                                    "org_unit": [{"uuid": org_unit_uuid}],
                                    "validity": {
                                        "from": datetime(
                                            2015,
                                            1,
                                            15,
                                            tzinfo=timezone(timedelta(hours=1)),
                                        ),
                                        "to": datetime(
                                            2015,
                                            1,
                                            30,
                                            tzinfo=timezone(timedelta(hours=1)),
                                        ),
                                    },
                                },
                            ]
                        }
                    ]
                }
            )
        )

        mo.get_employee_managers.return_value = GetManagersManagers.parse_obj(
            {
                "objects": [
                    {
                        "validities": [
                            {
                                "uuid": manager_uuid,
                                "org_unit": [{"uuid": org_unit_uuid}],
                                "person": [
                                    {
                                        "uuid": uuid.uuid4(),
                                        "engagements": [
                                            {
                                                "uuid": engagement_uuid,
                                                "org_unit": [{"uuid": org_unit_uuid}],
                                                "validity": {
                                                    "from": datetime(
                                                        2015,
                                                        1,
                                                        10,
                                                        tzinfo=timezone(
                                                            timedelta(hours=1)
                                                        ),
                                                    ),
                                                    "to": datetime(
                                                        2015,
                                                        1,
                                                        15,
                                                        tzinfo=timezone(
                                                            timedelta(hours=1)
                                                        ),
                                                    ),
                                                },
                                            },
                                            {
                                                "uuid": engagement_uuid,
                                                "org_unit": [{"uuid": org_unit_uuid}],
                                                "validity": {
                                                    "from": datetime(
                                                        2015,
                                                        1,
                                                        15,
                                                        tzinfo=timezone(
                                                            timedelta(hours=1)
                                                        ),
                                                    ),
                                                    "to": datetime(
                                                        2015,
                                                        1,
                                                        30,
                                                        tzinfo=timezone(
                                                            timedelta(hours=1)
                                                        ),
                                                    ),
                                                },
                                            },
                                        ],
                                        "validity": {
                                            "from": datetime(
                                                2000,
                                                1,
                                                1,
                                                tzinfo=timezone(timedelta(hours=1)),
                                            ),
                                            "to": None,
                                        },
                                    }
                                ],
                                "validity": {
                                    "from": datetime(
                                        2015,
                                        1,
                                        1,
                                        tzinfo=timezone(timedelta(hours=1)),
                                    ),
                                    "to": None,
                                },
                            }
                        ],
                    }
                ]
            }
        )

        mo.update_manager.return_value = manager_uuid

        # invoke
        await engagement_event_handler(mo, engagement_uuid, settings, None)
        mo.update_manager.assert_has_calls(
            [
                call(
                    uuid=manager_uuid,
                    vacant_from=date(2015, 1, 1),
                    vacant_to=date(2015, 1, 9),
                ),
                call(
                    uuid=manager_uuid,
                    vacant_from=date(2015, 1, 30),
                    vacant_to=None,
                ),
            ]
        )


@pytest.mark.asyncio
@pytest.mark.usefixtures("minimal_valid_settings")
async def test_engagement_event_handler_complex_data():
    settings = Settings()
    # test data
    test_data_root_engagement_uuid = uuid.uuid4()

    shared_org_unit_uuid = uuid.uuid4()
    shared_person_uuid_1 = uuid.uuid4()

    test_data_engagements = [
        {
            "uuid": uuid.uuid4(),
            "org_unit": [{"uuid": shared_org_unit_uuid}],
            "person": [{"uuid": shared_person_uuid_1}],
            "validity": {
                "from": datetime(2023, 1, 1, 0, 0, 0).replace(tzinfo=DEFAULT_TIMEZONE),
                "to": datetime(2023, 9, 1, 0, 0, 0).replace(tzinfo=DEFAULT_TIMEZONE),
            },
        },
        {
            "uuid": uuid.uuid4(),
            "org_unit": [{"uuid": shared_org_unit_uuid}],
            "person": [{"uuid": shared_person_uuid_1}],
            "validity": {
                "from": datetime(2023, 9, 25, 0, 0, 0).replace(tzinfo=DEFAULT_TIMEZONE),
                "to": datetime(2023, 9, 25, 0, 0, 0).replace(tzinfo=DEFAULT_TIMEZONE),
            },
        },
        {
            "uuid": uuid.uuid4(),
            "org_unit": [{"uuid": shared_org_unit_uuid}],
            "person": [{"uuid": shared_person_uuid_1}],
            "validity": {
                "from": datetime(2023, 9, 26, 0, 0, 0).replace(tzinfo=DEFAULT_TIMEZONE),
                "to": datetime(2023, 11, 17, 0, 0, 0).replace(tzinfo=DEFAULT_TIMEZONE),
            },
        },
        {
            "uuid": uuid.uuid4(),
            "org_unit": [{"uuid": shared_org_unit_uuid}],
            "person": [{"uuid": shared_person_uuid_1}],
            "validity": {
                "from": datetime(2023, 11, 1, 0, 0, 0).replace(tzinfo=DEFAULT_TIMEZONE),
                "to": None,
            },
        },
    ]

    test_data_managers = {
        "objects": [
            {
                "validities": [
                    {
                        "uuid": uuid.uuid4(),
                        "org_unit": [{"uuid": shared_org_unit_uuid}],
                        "person": [
                            {
                                "uuid": shared_person_uuid_1,
                                "engagements": test_data_engagements,
                            }
                        ],
                        "validity": {
                            "from": datetime(2023, 1, 1, 0, 0, 0).replace(
                                tzinfo=DEFAULT_TIMEZONE
                            ),
                            "to": None,
                        },
                    }
                ]
            },
        ]
    }

    # mocking
    get_engagement_objects_by_uuids_mock = AsyncMock(
        return_value=GetEngagementObjectsByUuidEngagements.parse_obj(
            {
                "objects": [
                    {
                        # NOTE: This object is just used to get the person_uuid,
                        # which is used later on to fetch employee managers
                        "validities": [
                            {
                                "uuid": uuid.uuid4(),
                                "org_unit": [{"uuid": shared_org_unit_uuid}],
                                "person": [{"uuid": shared_person_uuid_1}],
                                "validity": {
                                    "from": datetime(2023, 1, 1, 0, 0, 0).replace(
                                        tzinfo=DEFAULT_TIMEZONE
                                    ),
                                    "to": None,
                                },
                            },
                        ]
                    }
                ]
            }
        )
    )

    get_employee_managers_mock = AsyncMock(
        return_value=GetManagersManagers.parse_obj(test_data_managers)
    )

    terminate_manager_mock = AsyncMock(
        return_value=test_data_managers["objects"][0]["validities"][0]["uuid"]
    )

    mo_mock = AsyncMock(
        get_engagement_objects_by_uuids=get_engagement_objects_by_uuids_mock,
        get_employee_managers=get_employee_managers_mock,
        terminate_manager=terminate_manager_mock,
    )

    # invoke
    await engagement_event_handler(
        mo_mock, test_data_root_engagement_uuid, settings, None
    )

    # asserts
    get_engagement_objects_by_uuids_mock.assert_called_once()
    get_employee_managers_mock.assert_has_calls([call([shared_person_uuid_1])])
    terminate_manager_mock.assert_has_calls(
        [
            call(
                uuid=test_data_managers["objects"][0]["validities"][0]["uuid"],
                terminate_from=(
                    test_data_engagements[0]["validity"]["to"] + timedelta(days=1)
                ).date(),
                terminate_to=(
                    test_data_engagements[1]["validity"]["from"] - timedelta(days=1)
                ).date(),
            ),
        ]
    )


@pytest.mark.asyncio
@pytest.mark.usefixtures("minimal_valid_settings")
async def test_engagement_event_handler_engagements_across_orgunits():
    settings = Settings()
    # test data
    person_uuid_shared = uuid.uuid4()
    ou_uuid_1 = uuid.uuid4()
    ou_uuid_2 = uuid.uuid4()
    ou_uuid_3 = uuid.uuid4()

    test_data_engagements = [
        {
            "uuid": uuid.uuid4(),
            "person": [{"uuid": person_uuid_shared}],
            "org_unit": [{"uuid": ou_uuid_1}],
            "validity": {
                "from": datetime(2023, 1, 1, 0, 0, 0).replace(tzinfo=DEFAULT_TIMEZONE),
                "to": datetime(2023, 1, 15, 0, 0, 0).replace(tzinfo=DEFAULT_TIMEZONE),
            },
        },
        {
            "uuid": uuid.uuid4(),
            "person": [{"uuid": person_uuid_shared}],
            "org_unit": [{"uuid": ou_uuid_2}],
            "validity": {
                "from": datetime(2023, 5, 1, 0, 0, 0).replace(tzinfo=DEFAULT_TIMEZONE),
                "to": None,
            },
        },
        {
            "uuid": uuid.uuid4(),
            "person": [{"uuid": person_uuid_shared}],
            "org_unit": [{"uuid": ou_uuid_3}],
            "validity": {
                "from": datetime(2023, 4, 1, 0, 0, 0).replace(tzinfo=DEFAULT_TIMEZONE),
                "to": datetime(2023, 7, 10, 0, 0, 0).replace(tzinfo=DEFAULT_TIMEZONE),
            },
        },
        {
            "uuid": uuid.uuid4(),
            "person": [{"uuid": person_uuid_shared}],
            "org_unit": [{"uuid": ou_uuid_3}],
            "validity": {
                "from": datetime(2023, 9, 1, 0, 0, 0).replace(tzinfo=DEFAULT_TIMEZONE),
                "to": datetime(2023, 12, 1, 0, 0, 0).replace(tzinfo=DEFAULT_TIMEZONE),
            },
        },
    ]

    test_data_managers = {
        "objects": [
            {
                "validities": [
                    {
                        "uuid": uuid.uuid4(),
                        "org_unit": [{"uuid": ou_uuid_3}],
                        "person": [
                            {
                                "uuid": person_uuid_shared,
                                "engagements": test_data_engagements,
                            }
                        ],
                        "validity": {
                            "from": datetime(2023, 1, 1, 0, 0, 0).replace(
                                tzinfo=DEFAULT_TIMEZONE
                            ),
                            "to": None,
                        },
                    }
                ]
            },
        ]
    }

    test_data_event_engagement_uuid = uuid.uuid4()

    # mocking
    get_engagement_objects_by_uuids_mock = AsyncMock(
        return_value=GetEngagementObjectsByUuidEngagements.parse_obj(
            {
                "objects": [
                    {
                        # NOTE: This object is just used to get the person_uuid,
                        # which is used later on to fetch employee managers
                        "validities": [
                            {
                                "uuid": uuid.uuid4(),
                                "person": [{"uuid": person_uuid_shared}],
                                "org_unit": [{"uuid": ou_uuid_1}],
                                "validity": {
                                    "from": datetime(2023, 1, 1, 0, 0, 0).replace(
                                        tzinfo=DEFAULT_TIMEZONE
                                    ),
                                    "to": None,
                                },
                            }
                        ]
                    }
                ]
            }
        )
    )

    get_employee_managers_mock = AsyncMock(
        return_value=GetManagersManagers.parse_obj(test_data_managers)
    )

    terminate_manager_mock = AsyncMock(
        return_value=test_data_managers["objects"][0]["validities"][0]["uuid"]
    )

    mo_mock = AsyncMock(
        get_engagement_objects_by_uuids=get_engagement_objects_by_uuids_mock,
        get_employee_managers=get_employee_managers_mock,
        terminate_manager=terminate_manager_mock,
    )

    # invoke
    await engagement_event_handler(
        mo_mock, test_data_event_engagement_uuid, settings, None
    )

    # asserts
    get_engagement_objects_by_uuids_mock.assert_called_once()
    get_employee_managers_mock.assert_has_calls([call([person_uuid_shared])])
    terminate_manager_mock.assert_has_calls(
        [
            call(
                uuid=test_data_managers["objects"][0]["validities"][0]["uuid"],
                terminate_from=(
                    test_data_engagements[0]["validity"]["to"] + timedelta(days=1)
                ).date(),
                terminate_to=(
                    test_data_engagements[2]["validity"]["from"] - timedelta(days=1)
                ).date(),
            )
        ]
    )


@pytest.mark.asyncio
@pytest.mark.usefixtures("minimal_valid_settings")
async def test_engagement_event_handler_engagements_across_orgunits_no_infinity():
    settings = Settings()
    # test data
    person_uuid_shared = uuid.uuid4()
    ou_uuid_1 = uuid.uuid4()
    ou_uuid_2 = uuid.uuid4()
    ou_uuid_3 = uuid.uuid4()

    test_data_engagements = [
        {
            "uuid": uuid.uuid4(),
            "person": [{"uuid": person_uuid_shared}],
            "org_unit": [{"uuid": ou_uuid_1}],
            "validity": {
                "from": datetime(2023, 1, 1, 0, 0, 0).replace(tzinfo=DEFAULT_TIMEZONE),
                "to": datetime(2023, 2, 1, 0, 0, 0).replace(tzinfo=DEFAULT_TIMEZONE),
            },
        },
        {
            "uuid": uuid.uuid4(),
            "person": [{"uuid": person_uuid_shared}],
            "org_unit": [{"uuid": ou_uuid_2}],
            "validity": {
                "from": datetime(2023, 7, 1, 0, 0, 0).replace(tzinfo=DEFAULT_TIMEZONE),
                "to": datetime(2023, 8, 1, 0, 0, 0).replace(tzinfo=DEFAULT_TIMEZONE),
            },
        },
        {
            "uuid": uuid.uuid4(),
            "person": [{"uuid": person_uuid_shared}],
            "org_unit": [{"uuid": ou_uuid_3}],
            "validity": {
                "from": datetime(2023, 1, 1, 0, 0, 0).replace(tzinfo=DEFAULT_TIMEZONE),
                "to": datetime(2023, 5, 1, 0, 0, 0).replace(tzinfo=DEFAULT_TIMEZONE),
            },
        },
        {
            "uuid": uuid.uuid4(),
            "person": [{"uuid": person_uuid_shared}],
            "org_unit": [{"uuid": ou_uuid_3}],
            "validity": {
                "from": datetime(2023, 9, 1, 0, 0, 0).replace(tzinfo=DEFAULT_TIMEZONE),
                "to": datetime(2023, 11, 30, 0, 0, 0).replace(tzinfo=DEFAULT_TIMEZONE),
            },
        },
    ]

    test_data_managers = {
        "objects": [
            {
                "validities": [
                    {
                        "uuid": uuid.uuid4(),
                        "org_unit": [{"uuid": ou_uuid_1}],
                        "person": [
                            {
                                "uuid": person_uuid_shared,
                                "engagements": test_data_engagements,
                            }
                        ],
                        "validity": {
                            "from": datetime(2023, 1, 1, 0, 0, 0).replace(
                                tzinfo=DEFAULT_TIMEZONE
                            ),
                            "to": None,
                        },
                    }
                ]
            },
        ]
    }

    test_data_event_engagement_uuid = uuid.uuid4()

    # mocking
    get_engagement_objects_by_uuids_mock = AsyncMock(
        return_value=GetEngagementObjectsByUuidEngagements.parse_obj(
            {
                "objects": [
                    {
                        "validities": [
                            # NOTE: This object is just used to get the person_uuid,
                            # which is used later on to fetch employee managers
                            {
                                "uuid": uuid.uuid4(),
                                "person": [{"uuid": person_uuid_shared}],
                                "org_unit": [{"uuid": ou_uuid_1}],
                                "validity": {
                                    "from": datetime(2023, 1, 1, 0, 0, 0).replace(
                                        tzinfo=DEFAULT_TIMEZONE
                                    ),
                                    "to": None,
                                },
                            },
                        ]
                    }
                ]
            }
        )
    )

    get_employee_managers_mock = AsyncMock(
        return_value=GetManagersManagers.parse_obj(test_data_managers)
    )

    terminate_manager_mock = AsyncMock(
        return_value=test_data_managers["objects"][0]["validities"][0]["uuid"]
    )

    mo_mock = AsyncMock(
        get_engagement_objects_by_uuids=get_engagement_objects_by_uuids_mock,
        get_employee_managers=get_employee_managers_mock,
        terminate_manager=terminate_manager_mock,
    )

    # invoke
    await engagement_event_handler(
        mo_mock, test_data_event_engagement_uuid, settings, None
    )

    # asserts
    get_engagement_objects_by_uuids_mock.assert_called_once()
    get_employee_managers_mock.assert_has_calls([call([person_uuid_shared])])
    terminate_manager_mock.assert_has_calls(
        [
            call(
                uuid=test_data_managers["objects"][0]["validities"][0]["uuid"],
                terminate_from=(
                    test_data_engagements[2]["validity"]["to"] + timedelta(days=1)
                ).date(),
                terminate_to=(
                    test_data_engagements[1]["validity"]["from"] - timedelta(days=1)
                ).date(),
            ),
            call(
                uuid=test_data_managers["objects"][0]["validities"][0]["uuid"],
                terminate_from=(
                    test_data_engagements[1]["validity"]["to"] + timedelta(days=1)
                ).date(),
                terminate_to=(
                    test_data_engagements[3]["validity"]["from"] - timedelta(days=1)
                ).date(),
            ),
            call(
                uuid=test_data_managers["objects"][0]["validities"][0]["uuid"],
                terminate_from=None,
                terminate_to=test_data_engagements[3]["validity"]["to"].date(),
            ),
        ]
    )
